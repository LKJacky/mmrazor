# 如何适配trace新模型

首先我们提供一个单元测试：tests/test_core/test_graph/test_prune_tracer_model.py。
在这个文件中，我们自动的对模型进行测试，判断是否能够顺利通过PruneTracer。
当我们需要为一个repo适配tracer适配测试时，我们只需要增加该repo的模型到该单元测试即可。

## 添加新模型

我们使用一个类 ModelLibrary 来解析一个repo的模型，因此我们需要

- 实现一个repo的 ModelLibrary (tests/data/model_library.py)
  - 可以已经实现的 MMClsModelLibrary，MMDetModelLibrary，MMSegModelLibrary
- 将该 model library增加到 FxPassedModelManager 和 BackwardPassedModelManager (tests/data/tracer_passed_models.py) 中。
  - 请参考已经实现的 FxPassedModelManager.mmcls_library。
  - PassedModelManager需要能够通过字符串控制哪些模型参加测试，例如
    ```python
        @classmethod
        def mmcls_library(cls):
            """
            shufflenet consists of chunk operations.
            resnest: resnest has two problems. First it uses *x.shape() which is
                not tracerable using fx tracer. Second, it uses channel folding.
            res2net: res2net consists of split operations.
            convnext: consist of layernorm.
            """
            mmcls_include = [
                'vgg',
                'efficientnet',
                'resnet',
                'mobilenet',
                'resnext',
                'wide-resnet',
                'hrnet',
                'inception',
                'densenet',
                'regnet',
                'convmixer',
                'efficientformer',
                'mobileone',
                'edgenext',
                'seresnet',
                'repvgg',
                'seresnext',
                'conformer',
                'poolformer',
                'res2net',
                'resnest',
                'convnext',
                # errors
                # 'mvit', # error
                # 'van',  # bug
                # 'twins',  # bug
                # 'tnt',  # bug
                # 'repmlp',  # bug
                # 't2t',  # bug
                # 'swin',  # bug
                # 'shufflenet',  # bug
                # 'vit',  # bug
                # 'mlp',  # bug
            ]
            if cls._mmcls_library is None:
                cls._mmcls_library = MMClsModelLibrary(include=mmcls_include)
            return cls._mmcls_library
    ```

完成以上工作后，我们的单元测试应该能够自动对新的repo模型进行测试了。但是为了模型能够正确解析，我们需要一些简单的适配工作。

## 适配DemoInput

DemoInput主要作用是为openmmlab模型提供一个测试输入。PruneTracer默认使用DefaultDemoInput （mmrazor/models/task_modules/demo_inputs/default_demo_inputs.py） 生成输入。为了适配DefaultDemoInput，我们需要如下几个步骤。

- 实现 DefaultMMXxxDemoInput (/mmrazor/models/task_modules/demo_inputs/demo_inputs.py)，继承 DefaultMMDemoInput.
  - 可以参考已经实现的 DefaultMMClsDemoInput DefaultMMDetDemoInput。
- 修改 DefaultDemoInput， 使其在合适的时候调用 DefaultMMXxxDemoInput

## 运行单元测试，并且区分通过与不通过的模型

在完成以上步骤之后，我们可以运行我们的单元测试。

```python
python -m pytest tests -s -k 'test_prune_tracer_model'
```

修改PassedModelManager中的字符串，将不能通过的模型注释掉。

## 简单的模型适配(可选)

当我们发现一些模型无法通过tracer时，我们有一些简单的适配方法。

where to config prune tracer

- How to config PruneTracer using hard code
  - fxtracer
    - [default_demo_inputs.py](/mmrazor/models/task_modules/demo_inputs/default_demo_inputs.py)
    - leaf module
      - [prune_tracer.py](/mmrazor/models/task_modules/tracer/prune_tracer.py)::default_leaf_modules
  - ChannelNode
    - [channel_nodes.py](./mmrazor/structures/graph/channel_nodes.py)
  - DynamicOp
    [dynamic_conv.py](/mmrazor/models/architectures/dynamic_ops/bricks/dynamic_conv.py)

## 文档

./docs/en/user_guides/pruning_user_guide.md
